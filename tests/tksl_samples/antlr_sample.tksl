Graph add2(x: Int) -> (y: Int) {
    output (y: iadd(x, 2));
}

Graph add5(x: Int) -> (y: Int) {
    output (y: iadd(x, 5));
}

Graph dbl(x: Int) -> (x: Int) {
    // positional multiple outputs
    output (iadd(copy(x)));
}

// type aliases
type Point = Struct<p1: Float, p2: Int>;

Graph struc_id(in_st: Point) -> (out_st: Point) {
    output (out_st: in_st);
}

Graph main(v1: Int, v2: Pair<Int, Bool>) -> (o1: Int, o2:Int) {
    unp <- unpack_pair(v2);

    // declare constants
    const three = 3;
    other_total <- iadd(a:unp.first, b:three);


    pair_out <- make_pair(true, "asdf");
    // python_nodes::add(unp) -> other_total;

    total <- dbl(v1);
    quadruple <- sequence(dbl, dbl);

    total4 <- quadruple.sequenced();

    total.x -> total4.x;

    // equivalent1: if else block
    total4 <- if (unp.second; x: total4.x)  {
        output (y: add2(x));
    } else {
        output (y: add5(x));
    }; // shadowing output variables


    // equivalent2: lambda evaluation
    // sw <- switch(pred: True, if_true: add2, if_false: add5);
    // total4 <- sw.value(x:total4.x);

    // loop with condition
    looped_total <- while (x: other_total.value) {
        output (pred: ilt(x, 100));
    } do {
        output (x: add5(x));
    };


    const stuc = Point{p1: 4.3e1, p2: 3};

    disc <- struc_id(stuc);

    output (o1:total4.y, o2: looped_total.x);
}
