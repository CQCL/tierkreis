// preprocessing macro
include!("include_adders.tksl");

// type aliases
type Point = Struct<p1: Float, p2: Int>;

Graph struc_id(in_st: Point) -> (out_st: Point) {
    output (out_st: in_st);
}

Graph func(v1: Int, v2: Pair<Int, Bool>) -> (o1: Int, o2:Int) {
    unp <- unpack_pair(v2);

    // declare constants
    const three = 3;
    other_total <- iadd(a:unp.first, b:three);


    pair_out <- make_pair(true, "asdf");
    // python_nodes::add(unp) -> other_total;

    total <- dbl(v1);
    quadruple <- sequence(dbl, dbl);

    total4 <- quadruple.sequenced();

    total.x -> total4.x;

    // equivalent1: if else block
    total4 <- if (unp.second; x: total4.x)  {
        output (y: add2(x));
    } else {
        output (y: add5(x));
    }; // shadowing output variables


    // equivalent2: lambda evaluation
    // sw <- switch(pred: True, if_true: add2, if_false: add5);
    // total4 <- sw.value(x:total4.x);

    // loop with condition
    looped_total <- loop (value: other_total.value) {
        xs <- copy(value);
        x <- if (ilt(xs.value_0, 100); x: xs.value_1) {
            output (value: tag(continue: add5(x)));
        } else {
            output (value: tag(break: x));
        };

        output (value: x.value);
    };

    const stuc = Point{p1: 4.3e1, p2: 3};

    disc <- struc_id(stuc);

    output (o1:total4.y, o2: looped_total.value);
}


Graph main() -> (o1: Int, o2: Int) {
    output (func(3, (2, true)));
}
