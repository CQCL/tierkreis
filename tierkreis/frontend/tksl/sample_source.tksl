def add2(x: int) -> (y: int) {
    output(y: python_nodes::add(x, 2))
}

def add5(x: int) -> (y: int) {
    output(y: python_nodes::add(x, 5))
}

def double(x: int) -> (x2: int) {
    output(python_nodes::add(copy(x)))
}

# type aliases
type Point = struct<p1: float, p2: int>

def struc_id(in_st: Point) -> (out_st: Point) {
    output(out_st: in_st)
}

def main(v1: int, v2: pair<int, bool>) -> (o1: int, o2:int) {
    unpack_pair(v2) -> unp
    
    # declare constants
    const three = 3
    python_nodes::add(a:unp.first, b:three) -> other_total
    make_pair(True, "asdf") -> pair
    # python_nodes::add(unp) -> other_total

    # positional multiple outputs
    double(v1) -> total

    # equivalent1: if else block
    if (unp.second; x: total)  {
        output(y: add2(x))
    } else {
        output(y: add5(x))
    } -> total # shadowing output variables
    

    # equivalent2: lambda evaluation
    # switch(predicate: True, true: add2, false: add5) -> sw
    # sw.value(x:total.value) -> total

    # loop with condition
    while (x: other_total.value) {
        output(pred: python_nodes::less_than(x:x, y:100))
    } do {
        output(x: add5(x))
    } -> looped_total


    const stuc = Point{p1: 0.43, p2: 3}

    struc_id(stuc) -> disc

    output(o1:total.y, o2: looped_total.x)
}